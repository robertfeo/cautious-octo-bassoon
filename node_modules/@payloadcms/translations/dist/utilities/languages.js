export const rtlLanguages = ['ar', 'fa'];
export const acceptedLanguages = [
    'ar',
    'az',
    'bg',
    'cs',
    'de',
    'en',
    'es',
    'fa',
    'fr',
    'hr',
    'hu',
    'it',
    'ja',
    'ko',
    'my',
    'nb',
    'nl',
    'pl',
    'pt',
    'ro',
    'rs',
    'rsLatin',
    'ru',
    'sk',
    'sv',
    'th',
    'tr',
    'uk',
    'vi',
    'zh',
    'zh-TW',
    /**
     * Languages not implemented:
     *
     * 'af',
     * 'am',
     * 'ar-sa',
     * 'as',
     * 'az-latin',
     * 'be',
     * 'bn-BD',
     * 'bn-IN',
     * 'bs',
     * 'ca',
     * 'ca-ES-valencia',
     * 'cy',
     * 'da',
     * 'el',
     * 'en-GB',
     * 'en-US',
     * 'es-ES',
     * 'es-US',
     * 'es-MX',
     * 'et',
     * 'eu',
     * 'fi',
     * 'fil-Latn',
     * 'fr-FR',
     * 'fr-CA',
     * 'ga',
     * 'gd-Latn',
     * 'gl',
     * 'gu',
     * 'ha-Latn',
     * 'he',
     * 'hi',
     * 'hr',
     * 'hy',
     * 'id',
     * 'ig-Latn',
     * 'is',
     * 'it-it',
     * 'ka',
     * 'kk',
     * 'km',
     * 'kn',
     * 'kok',
     * 'ku-Arab',
     * 'ky-Cyrl',
     * 'lb',
     * 'lt',
     * 'lv',
     * 'mi-Latn',
     * 'mk',
     * 'ml',
     * 'mn-Cyrl',
     * 'mr',
     * 'ms',
     * 'mt',
     * 'ne',
     * 'nl-BE',
     * 'nn',
     * 'nso',
     * 'or',
     * 'pa',
     * 'pa-Arab',
     * 'prs-Arab',
     * 'pt-BR',
     * 'pt-PT',
     * 'qut-Latn',
     * 'quz',
     * 'rw',
     * 'sd-Arab',
     * 'si',
     * 'sl',
     * 'sq',
     * 'sr-Cyrl-BA',
     * 'sr-Cyrl-RS',
     * 'sr-Latn-RS',
     * 'sw',
     * 'ta',
     * 'te',
     * 'tg-Cyrl',
     * 'ti',
     * 'tk-Latn',
     * 'tn',
     * 'tt-Cyrl',
     * 'ug-Arab',
     * 'ur',
     * 'uz-Latn',
     * 'wo',
     * 'xh',
     * 'yo-Latn',
     * 'zh-Hans',
     * 'zh-Hant',
     * 'zu',
     */
];
function parseAcceptLanguage(acceptLanguageHeader) {
    return acceptLanguageHeader
        .split(',')
        .map((lang) => {
        const [language, quality] = lang.trim().split(';q=');
        return {
            language,
            quality: quality ? parseFloat(quality) : 1,
        };
    })
        .sort((a, b) => b.quality - a.quality); // Sort by quality, highest to lowest
}
export function extractHeaderLanguage(acceptLanguageHeader) {
    const parsedHeader = parseAcceptLanguage(acceptLanguageHeader);
    let matchedLanguage;
    for (const { language } of parsedHeader) {
        if (!matchedLanguage && acceptedLanguages.includes(language)) {
            matchedLanguage = language;
        }
    }
    return matchedLanguage;
}
//# sourceMappingURL=languages.js.map